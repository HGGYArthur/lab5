% Определение диапазона степеней двойки для числа N
pb(N, L, U) :-                         
    N > 0,                             
    pbh(N, 0, L, U).                   % Вызываем вспомогательный предикат pbh с начальной степенью 0.

pbh(N, P, P, NP) :-                    % База рекурсии-определяем когда N находится между двумя степенями двойки.
    TP is 2**P,                        % Вычисляем 2 в степени P (меньшее значение).
    TNP is 2**(P + 1),                 % Вычисляем 2 в степени P+1 (большее значение).
    N >= TP,                           % N >= 2^P.
    N < TNP,                           % N < 2^(P+1).
    NP is P + 1.                      % Устанавливаем NP как P + 1 для дальнейшего рассмотрения.

pbh(N, P, L, U) :-                      % Рекурсивный шаг для поиска подходящего диапазона.
    TP is 2**P,                        
    N >= TP,                           
    NP is P + 1,                       
    pbh(N, NP, L, U).                  % Рекурсивно вызываем pbh с новой степенью NP.

% Обработка списка и вычисление общего диапазона степеней двойки
pl([], L, U, L, U).                     % База рекурсии: если список пуст, возвращаем текущие значения L и U.

pl([H | T], LIn, UIn, LOut, UOut) :-    % Обработка непустого списка, где H - голова, а T - хвост списка.
    (H > 0 ->                          
        pb(H, LH, UH),                % Вычисляем диапазон степеней двойки для H.
        (LH < LIn -> NL = LH ; NL = LIn),  % Обновляем нижнюю границу диапазона.
        (UH > UIn -> NU = UH ; NU = UIn),  % Обновляем верхнюю границу диапазона.
        pl(T, NL, NU, LOut, UOut)     % Рекурсивно обрабатываем остаток списка T.
    ;                                  
        pl(T, LIn, UIn, LOut, UOut)   % Продолжаем обработку без изменений границ LIn и UIn.
    ).

% Вывод результата
t(L) :-                                
    pl(L, 1000, -1, L1, U1),           % Вызываем pl с начальной нижней границей 1000 и верхней -1.
    format('Степени двойки: 2^~w - 2^~w. Сортировка списка: ~w~n', [L1, U1, L]).  

% Сортировка списка
fm([X], X, []).                        % База рекурсии: если список состоит из одного элемента, он является минимальным.

fm([H | T], M, [H | R]) :-              % Непустой список: ищем минимальный элемент среди H и элементов T.
    fm(T, TM, R),                     % Рекурсивно ищем минимальный элемент TM во хвосте.
    TM < H,                           
    M = TM.                           

fm([H | T], H, T) :-                    % Если H меньше или равен минимальному TM:
    fm(T, TM, _),                     % Находим минимальный элемент во хвосте.
    H =< TM.                          % H считается минимальным.

ss([], []).                             % База рекурсии: если список пуст, возвращаем пустой список.

ss(L, [M | S]) :-                       % Непустой список: находим минимальный элемент.
    fm(L, M, R),                       % Используем fm для нахождения минимального M и остатка R.
    ss(R, S).                          % Рекурсивно сортируем оставшийся список R.

% Основной предикат
t1 :-                                 
    write('Введите список чисел в формате [число1, число2, ..., числоN]: '), 
    read(L),                           
    ss(L, S),                          
    t(S).                               
